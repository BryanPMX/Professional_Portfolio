---
import Layout from '../../layouts/Layout.astro';
---

<Layout title="Snake Game - Bryan Perez">
  <div class="min-h-screen py-8 px-6">
    <div class="max-w-6xl mx-auto">
      <!-- Header -->
      <div class="text-center mb-8">
        <h1 class="text-4xl font-bold mb-4 text-accent-purple">Snake Game</h1>
        <p class="text-dark-text-secondary text-lg max-w-2xl mx-auto">
          Classic snake, cleaner feel. Eat, grow, and survive the speed ramp.
        </p>
      </div>

      <!-- Game Container -->
      <div class="bg-dark-card rounded-xl border border-dark-surface p-6 mb-8">
        <div class="flex justify-center mb-4">
          <canvas 
            id="gameCanvas" 
            width="600" 
            height="600"
            class="border border-dark-surface rounded-lg bg-dark-bg max-w-full"
          ></canvas>
        </div>
        
        <!-- Game Controls -->
        <div class="text-center">
          <button 
            id="startBtn"
            class="bg-accent-purple hover:bg-accent-purple-hover text-white px-6 py-2 rounded-lg font-semibold transition-colors mr-4"
          >
            Start Game
          </button>
          <button 
            id="pauseBtn"
            class="bg-dark-surface hover:bg-dark-bg text-dark-text px-6 py-2 rounded-lg font-semibold transition-colors border border-dark-surface mr-4"
          >
            Pause
          </button>
          <button 
            id="resetBtn"
            class="bg-red-600 hover:bg-red-700 text-white px-6 py-2 rounded-lg font-semibold transition-colors"
          >
            Reset
          </button>
        </div>
        
        <!-- Score Display -->
        <div class="flex justify-center mt-4 gap-6">
          <div class="bg-dark-surface px-6 py-2 rounded-lg border border-dark-surface">
            <span class="text-dark-text-secondary">Score: </span>
            <span id="score" class="text-accent-purple font-bold text-lg">0</span>
          </div>
          <div class="bg-dark-surface px-6 py-2 rounded-lg border border-dark-surface">
            <span class="text-dark-text-secondary">High Score: </span>
            <span id="highScore" class="text-accent font-bold text-lg">0</span>
          </div>
        </div>
      </div>

      <!-- Main Menu Overlay -->
      <div id="mainMenu" class="fixed inset-0 bg-black bg-opacity-80 flex items-center justify-center z-50">
        <div class="bg-dark-card p-8 rounded-xl border border-accent max-w-md w-full mx-4 text-center">
          <h2 class="text-3xl font-bold text-accent-purple mb-4">Snake Game</h2>
          <p class="text-dark-text-secondary mb-6">
            Grow your run without crashing.
          </p>
          <div class="space-y-3 mb-6">
            <div class="text-sm text-dark-text-secondary">
              <strong>Controls:</strong><br>
              Arrow keys to move
            </div>
            <div class="text-sm text-dark-text-secondary">
              <strong>Objective:</strong><br>
              Stay alive and score high.
            </div>
          </div>
          <button
            id="startGameBtn"
            class="bg-accent hover:bg-accent-hover text-white px-8 py-3 rounded-lg font-semibold transition-colors text-lg"
          >
            Start Game
          </button>
        </div>
      </div>

      <!-- Game Over Overlay -->
      <div id="gameOver" class="fixed inset-0 bg-black bg-opacity-80 flex items-center justify-center z-50 hidden">
        <div class="bg-dark-card p-8 rounded-xl border border-accent max-w-md w-full mx-4 text-center">
          <h2 class="text-3xl font-bold text-red-400 mb-4">Game Over!</h2>
          <div class="space-y-2 mb-6">
            <p class="text-dark-text-secondary">Final Score: <span id="finalScore" class="text-accent-purple font-bold text-xl">0</span></p>
            <p class="text-dark-text-secondary">High Score: <span id="finalHighScore" class="text-accent font-bold text-xl">0</span></p>
          </div>
          <div class="flex gap-3 justify-center">
            <button
              id="playAgainBtn"
              class="bg-accent hover:bg-accent-hover text-white px-6 py-2 rounded-lg font-semibold transition-colors"
            >
              Play Again
            </button>
            <button
              id="backToMenuBtn"
              class="bg-dark-surface hover:bg-dark-bg text-dark-text px-6 py-2 rounded-lg font-semibold transition-colors border border-dark-surface"
            >
              Main Menu
            </button>
          </div>
        </div>
      </div>

      <!-- Game Instructions -->
      <div class="grid grid-cols-1 md:grid-cols-2 gap-8 mb-8">
        <div class="bg-dark-surface p-6 rounded-xl border border-dark-surface">
          <h3 class="text-xl font-semibold mb-4 text-accent">How to Play</h3>
          <ul class="space-y-2 text-dark-text-secondary">
            <li class="flex items-center gap-2">
              <span class="w-2 h-2 bg-accent rounded-full"></span>
              Use arrow keys to steer
            </li>
            <li class="flex items-center gap-2">
              <span class="w-2 h-2 bg-accent rounded-full"></span>
              Eat food to grow and score
            </li>
            <li class="flex items-center gap-2">
              <span class="w-2 h-2 bg-accent rounded-full"></span>
              Avoid walls and your tail
            </li>
            <li class="flex items-center gap-2">
              <span class="w-2 h-2 bg-accent rounded-full"></span>
              Speed rises as score climbs
            </li>
          </ul>
        </div>
        
        <div class="bg-dark-surface p-6 rounded-xl border border-dark-surface">
          <h3 class="text-xl font-semibold mb-4 text-accent-purple">Highlights</h3>
          <ul class="space-y-2 text-dark-text-secondary">
            <li class="flex items-center gap-2">
              <span class="w-2 h-2 bg-accent-purple rounded-full"></span>
              Responsive movement
            </li>
            <li class="flex items-center gap-2">
              <span class="w-2 h-2 bg-accent-purple rounded-full"></span>
              Progressive speed
            </li>
            <li class="flex items-center gap-2">
              <span class="w-2 h-2 bg-accent-purple rounded-full"></span>
              Local high-score tracking
            </li>
            <li class="flex items-center gap-2">
              <span class="w-2 h-2 bg-accent-purple rounded-full"></span>
              Clean arcade styling
            </li>
          </ul>
        </div>
      </div>

      <!-- Navigation -->
      <div class="text-center">
        <div class="flex flex-col sm:flex-row gap-4 justify-center">
          <a 
            href="/games" 
            class="bg-dark-surface hover:bg-dark-bg text-dark-text px-6 py-2 rounded-lg font-semibold transition-colors border border-dark-surface hover:border-accent"
          >
            ‚Üê Back
          </a>
          <a 
            href="https://github.com/BryanPMX/snake-game" 
            target="_blank"
            class="bg-accent hover:bg-accent-hover text-white px-6 py-2 rounded-lg font-semibold transition-colors"
          >
            Source
          </a>
        </div>
      </div>
    </div>
  </div>
</Layout>

<script>
  // @ts-nocheck
  // Snake Game Implementation - Following Software Engineering Principles

  // Configuration constants - Single Source of Truth
  const SNAKE_CONFIG = {
    GRID_SIZE: 20,
    INITIAL_SNAKE: [{ x: 10, y: 10 }],
    INITIAL_FOOD: { x: 15, y: 15 },
    INITIAL_SPEED: 1,
    POWER_UP_DURATION: 300, // frames
    PARTICLE_COUNT: 50,
    GAME_STATES: {
      MENU: 'menu',
      PLAYING: 'playing',
      PAUSED: 'paused',
      GAME_OVER: 'gameOver'
    }
  };

  // Game State Manager - State Pattern Implementation
  class GameStateManager {
    constructor(game) {
      this.game = game;
      this.currentState = SNAKE_CONFIG.GAME_STATES.MENU;
      this.states = {
        [SNAKE_CONFIG.GAME_STATES.MENU]: new MenuState(),
        [SNAKE_CONFIG.GAME_STATES.PLAYING]: new PlayingState(),
        [SNAKE_CONFIG.GAME_STATES.PAUSED]: new PausedState(),
        [SNAKE_CONFIG.GAME_STATES.GAME_OVER]: new GameOverState()
      };
    }

    setState(state) {
      if (this.states[state]) {
        this.currentState = state;
        this.states[state].enter(this.game);
      }
    }

    getCurrentState() {
      return this.currentState;
    }
  }

  // Abstract State Class - Template Method Pattern
  class GameState {
    enter(game) { /* Override in subclasses */ }
    update(game) { /* Override in subclasses */ }
    handleInput(game, key) { /* Override in subclasses */ }
  }

  class MenuState extends GameState {
    enter(game) {
      UIManager.showMainMenu();
    }
  }

  class PlayingState extends GameState {
    enter(game) {
      UIManager.hideMainMenu();
      UIManager.hideGameOver();
    }

    update(game) {
      game.updateGameLogic();
    }

    handleInput(game, key) {
      game.handleGameInput(key);
    }
  }

  class PausedState extends GameState {
    enter() {
      // Handle pause UI
    }
  }

  class GameOverState extends GameState {
    enter(game) {
      UIManager.showGameOver(game.score, game.highScore);
    }
  }

  // UI Manager - Single Responsibility for UI operations
  class UIManager {
    static showMainMenu() {
      document.getElementById('mainMenu').classList.remove('hidden');
      document.getElementById('gameOver').classList.add('hidden');
    }

    static hideMainMenu() {
      document.getElementById('mainMenu').classList.add('hidden');
    }

    static showGameOver(score, highScore) {
      document.getElementById('finalScore').textContent = score;
      document.getElementById('finalHighScore').textContent = highScore;
      document.getElementById('gameOver').classList.remove('hidden');
    }

    static hideGameOver() {
      document.getElementById('gameOver').classList.add('hidden');
    }

    static updateScore(score) {
      document.getElementById('score').textContent = score;
    }

    static updateHighScore(highScore) {
      document.getElementById('highScore').textContent = highScore;
    }
  }

  // Input Manager - Handles all input operations
  class InputManager {
    constructor(game) {
      this.game = game;
      this.keys = {};
      this.setupEventListeners();
    }

    setupEventListeners() {
      document.addEventListener('keydown', (e) => this.handleKeyDown(e));
      document.addEventListener('keyup', (e) => this.handleKeyUp(e));
    }

    handleKeyDown(e) {
      this.keys[e.key] = true;

      // Prevent default for game control keys when playing
      if (this.game.stateManager.getCurrentState() === SNAKE_CONFIG.GAME_STATES.PLAYING) {
        switch(e.key) {
          case 'ArrowUp':
          case 'ArrowDown':
          case 'ArrowLeft':
          case 'ArrowRight':
            e.preventDefault();
            break;
        }
      }

      this.game.stateManager.states[this.game.stateManager.getCurrentState()].handleInput(this.game, e.key);
    }

    handleKeyUp(e) {
      this.keys[e.key] = false;
    }

    isKeyPressed(key) {
      return !!this.keys[key];
    }
  }

  // Storage Manager - Handles localStorage operations
  class StorageManager {
    static getHighScore() {
      return parseInt(localStorage.getItem('snakeHighScore') || '0');
    }

    static setHighScore(score) {
      localStorage.setItem('snakeHighScore', score.toString());
    }
  }

  // Main Snake Game Class - Now focused on core game logic
  class SnakeGame {
    constructor(canvas) {
      // Validate input parameters
      if (!canvas || !(canvas instanceof HTMLCanvasElement)) {
        throw new Error('Valid canvas element required');
      }

      // Core game properties
      this.canvas = canvas;
      this.ctx = canvas.getContext('2d');
      this.gridSize = SNAKE_CONFIG.GRID_SIZE;
      this.tileCount = canvas.width / this.gridSize;

      // Game state - using State pattern
      this.stateManager = new GameStateManager(this);
      this.inputManager = new InputManager(this);

      // Game entities
      this.snake = [...SNAKE_CONFIG.INITIAL_SNAKE];
      this.food = { ...SNAKE_CONFIG.INITIAL_FOOD };
      this.dx = 0;
      this.dy = 0;
      this.score = 0;
      this.powerUp = null;
      this.powerUpTimer = 0;

      // Visual elements
      this.particles = [];
      this.gradientBg = this.createGradientBackground();
      this.foodGlow = 0;
      this.snakeSegments = [];

      // Load persistent data
      this.highScore = StorageManager.getHighScore();
      UIManager.updateHighScore(this.highScore);

      // Initialize game
      this.generateFood();
      this.createParticles();
      this.stateManager.setState(SNAKE_CONFIG.GAME_STATES.MENU);
    }

    // UI Management - Delegated to UIManager
    showMainMenu() {
      UIManager.showMainMenu();
    }

    hideMainMenu() {
      UIManager.hideMainMenu();
    }

    showGameOver() {
      UIManager.showGameOver(this.score, this.highScore);
    }

    hideGameOver() {
      UIManager.hideGameOver();
    }

    // Input handling - Delegated to InputManager
    handleGameInput(key) {
      if (this.stateManager.getCurrentState() !== SNAKE_CONFIG.GAME_STATES.PLAYING) return;

      switch(key) {
        case 'ArrowUp':
          if (this.dy !== SNAKE_CONFIG.INITIAL_SPEED) {
            this.dx = 0;
            this.dy = -SNAKE_CONFIG.INITIAL_SPEED;
          }
          break;
        case 'ArrowDown':
          if (this.dy !== -SNAKE_CONFIG.INITIAL_SPEED) {
            this.dx = 0;
            this.dy = SNAKE_CONFIG.INITIAL_SPEED;
          }
          break;
        case 'ArrowLeft':
          if (this.dx !== SNAKE_CONFIG.INITIAL_SPEED) {
            this.dx = -SNAKE_CONFIG.INITIAL_SPEED;
            this.dy = 0;
          }
          break;
        case 'ArrowRight':
          if (this.dx !== -SNAKE_CONFIG.INITIAL_SPEED) {
            this.dx = SNAKE_CONFIG.INITIAL_SPEED;
            this.dy = 0;
          }
          break;
      }
    }

    createGradientBackground() {
      const gradient = this.ctx.createLinearGradient(0, 0, this.canvas.width, this.canvas.height);
      gradient.addColorStop(0, '#0f0f0f');
      gradient.addColorStop(0.5, '#1a1a1a');
      gradient.addColorStop(1, '#0f0f0f');
      return gradient;
    }

    createParticles() {
      // Create floating particles for background effect
      for (let i = 0; i < 50; i++) {
        this.particles.push({
          x: Math.random() * this.canvas.width,
          y: Math.random() * this.canvas.height,
          vx: (Math.random() - 0.5) * 0.5,
          vy: (Math.random() - 0.5) * 0.5,
          size: Math.random() * 2 + 1,
          opacity: Math.random() * 0.5 + 0.2
        });
      }
    }

    generatePowerUp() {
      if (Math.random() < 0.3 && !this.powerUp) { // 30% chance to spawn power-up
        this.powerUp = {
          x: Math.floor(Math.random() * this.tileCount),
          y: Math.floor(Math.random() * this.tileCount),
          type: Math.random() < 0.5 ? 'speed' : 'score', // Speed boost or double score
          timer: 300 // 5 seconds at 60fps
        };
      }
    }
    
    generateFood() {
      this.food = {
        x: Math.floor(Math.random() * this.tileCount),
        y: Math.floor(Math.random() * this.tileCount)
      };

      // Make sure food doesn't spawn on snake or power-up
      for (let segment of this.snake) {
        if (segment.x === this.food.x && segment.y === this.food.y) {
          this.generateFood();
          return;
        }
      }

      if (this.powerUp && this.powerUp.x === this.food.x && this.powerUp.y === this.food.y) {
        this.generateFood();
        return;
      }
    }
    
    update() {
      if (!this.gameRunning || this.gamePaused) return;

      // Update particles
      this.particles.forEach(particle => {
        particle.x += particle.vx;
        particle.y += particle.vy;

        // Wrap around edges
        if (particle.x < 0) particle.x = this.canvas.width;
        if (particle.x > this.canvas.width) particle.x = 0;
        if (particle.y < 0) particle.y = this.canvas.height;
        if (particle.y > this.canvas.height) particle.y = 0;
      });

      // Update food glow animation
      this.foodGlow = (this.foodGlow + 0.1) % (Math.PI * 2);

      const head = { x: this.snake[0].x + this.dx, y: this.snake[0].y + this.dy };

      // Check wall collision
      if (head.x < 0 || head.x >= this.tileCount || head.y < 0 || head.y >= this.tileCount) {
        this.createExplosionParticles(head.x * this.gridSize + this.gridSize/2, head.y * this.gridSize + this.gridSize/2);
        this.gameOver();
        return;
      }

      // Check self collision
      for (let segment of this.snake) {
        if (head.x === segment.x && head.y === segment.y) {
          this.createExplosionParticles(head.x * this.gridSize + this.gridSize/2, head.y * this.gridSize + this.gridSize/2);
          this.gameOver();
          return;
        }
      }

      this.snake.unshift(head);

      // Check food collision
      if (head.x === this.food.x && head.y === this.food.y) {
        // Create particle effect for eating food
        this.createFoodParticles(this.food.x * this.gridSize + this.gridSize/2, this.food.y * this.gridSize + this.gridSize/2);

        const points = this.powerUp && this.powerUp.type === 'score' ? 20 : 10;
        this.score += points;
        this.updateScore();
        this.generateFood();
        this.generatePowerUp();
      } else {
        this.snake.pop();
      }

      // Check power-up collision
      if (this.powerUp && head.x === this.powerUp.x && head.y === this.powerUp.y) {
        this.activatePowerUp(this.powerUp.type);
        this.powerUp = null;
        this.powerUpTimer = 0;
      }

      // Update power-up timer
      if (this.powerUp) {
        this.powerUp.timer--;
        if (this.powerUp.timer <= 0) {
          this.powerUp = null;
        }
      }

      if (this.powerUpTimer > 0) {
        this.powerUpTimer--;
        if (this.powerUpTimer === 0) {
          // Reset speed when power-up expires
          // Speed reset logic would go here
        }
      }
    }
    
    createExplosionParticles(x, y) {
      for (let i = 0; i < 20; i++) {
        this.particles.push({
          x: x,
          y: y,
          vx: (Math.random() - 0.5) * 8,
          vy: (Math.random() - 0.5) * 8,
          size: Math.random() * 4 + 2,
          opacity: 1,
          life: 60,
          color: '#ef4444'
        });
      }
    }

    createFoodParticles(x, y) {
      for (let i = 0; i < 10; i++) {
        this.particles.push({
          x: x,
          y: y,
          vx: (Math.random() - 0.5) * 4,
          vy: (Math.random() - 0.5) * 4,
          size: Math.random() * 3 + 1,
          opacity: 1,
          life: 30,
          color: '#10b981'
        });
      }
    }

    activatePowerUp(type) {
      if (type === 'speed') {
        // Speed boost effect (would modify movement speed)
        this.powerUpTimer = 300; // 5 seconds
        // Visual feedback for speed boost
        this.createSpeedParticles();
      } else if (type === 'score') {
        // Double score effect (already handled in food collision)
      }
    }

    createSpeedParticles() {
      const head = this.snake[0];
      for (let i = 0; i < 15; i++) {
        this.particles.push({
          x: head.x * this.gridSize + this.gridSize/2,
          y: head.y * this.gridSize + this.gridSize/2,
          vx: (Math.random() - 0.5) * 6,
          vy: (Math.random() - 0.5) * 6,
          size: Math.random() * 2 + 1,
          opacity: 1,
          life: 20,
          color: '#f59e0b'
        });
      }
    }

    draw() {
      // Clear canvas with gradient background
      this.ctx.fillStyle = this.gradientBg;
      this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

      // Draw animated particles background
      this.ctx.globalAlpha = 0.6;
      this.particles.forEach(particle => {
        if (particle.life !== undefined) {
          // Effect particles
          this.ctx.fillStyle = particle.color;
          this.ctx.globalAlpha = particle.opacity * (particle.life / 60);
          this.ctx.beginPath();
          this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
          this.ctx.fill();
          particle.life--;
          particle.opacity *= 0.98;
        } else {
          // Background particles
          this.ctx.fillStyle = '#3b82f6';
          this.ctx.globalAlpha = particle.opacity;
          this.ctx.beginPath();
          this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
          this.ctx.fill();
        }
      });
      this.ctx.globalAlpha = 1;

      // Draw subtle grid
      this.ctx.strokeStyle = '#262626';
      this.ctx.lineWidth = 1;
      this.ctx.globalAlpha = 0.3;
      for (let i = 0; i <= this.tileCount; i++) {
        this.ctx.beginPath();
        this.ctx.moveTo(i * this.gridSize, 0);
        this.ctx.lineTo(i * this.gridSize, this.canvas.height);
        this.ctx.stroke();

        this.ctx.beginPath();
        this.ctx.moveTo(0, i * this.gridSize);
        this.ctx.lineTo(this.canvas.width, i * this.gridSize);
        this.ctx.stroke();
      }
      this.ctx.globalAlpha = 1;

      // Draw snake with enhanced visuals
      for (let i = 0; i < this.snake.length; i++) {
        const segment = this.snake[i];
        const x = segment.x * this.gridSize + 2;
        const y = segment.y * this.gridSize + 2;
        const width = this.gridSize - 4;
        const height = this.gridSize - 4;

        // Create gradient for snake segments
        const segmentGradient = this.ctx.createLinearGradient(x, y, x + width, y + height);
        if (i === 0) {
          // Snake head - more vibrant
          segmentGradient.addColorStop(0, '#a855f7');
          segmentGradient.addColorStop(1, '#7c3aed');
        } else {
          // Snake body - gradient based on position
          const intensity = 1 - (i / this.snake.length) * 0.5;
          segmentGradient.addColorStop(0, `rgba(139, 92, 246, ${intensity})`);
          segmentGradient.addColorStop(1, `rgba(124, 58, 237, ${intensity})`);
        }

        // Draw rounded rectangle for snake segments
        this.ctx.fillStyle = segmentGradient;
        this.roundRect(x, y, width, height, 4);
        this.ctx.fill();

        // Add subtle border
        this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
        this.ctx.lineWidth = 1;
        this.roundRect(x, y, width, height, 4);
        this.ctx.stroke();
      }

      // Draw food with glow effect
      const foodX = this.food.x * this.gridSize + 2;
      const foodY = this.food.y * this.gridSize + 2;
      const foodSize = this.gridSize - 4;

      // Glow effect
      const glowIntensity = (Math.sin(this.foodGlow) + 1) / 2;
      this.ctx.shadowColor = '#ef4444';
      this.ctx.shadowBlur = 10 + glowIntensity * 5;

      // Food gradient
      const foodGradient = this.ctx.createRadialGradient(
        foodX + foodSize/2, foodY + foodSize/2, 0,
        foodX + foodSize/2, foodY + foodSize/2, foodSize/2
      );
      foodGradient.addColorStop(0, '#fca5a5');
      foodGradient.addColorStop(1, '#ef4444');

      this.ctx.fillStyle = foodGradient;
      this.roundRect(foodX, foodY, foodSize, foodSize, 6);
      this.ctx.fill();

      // Reset shadow
      this.ctx.shadowBlur = 0;

      // Draw power-up if active
      if (this.powerUp) {
        const powerX = this.powerUp.x * this.gridSize + 2;
        const powerY = this.powerUp.y * this.gridSize + 2;
        const powerSize = this.gridSize - 4;

        // Pulsing effect for power-up
        const pulseScale = 1 + Math.sin(Date.now() * 0.01) * 0.1;

        this.ctx.save();
        this.ctx.translate(powerX + powerSize/2, powerY + powerSize/2);
        this.ctx.scale(pulseScale, pulseScale);
        this.ctx.translate(-(powerX + powerSize/2), -(powerY + powerSize/2));

        const powerColor = this.powerUp.type === 'speed' ? '#f59e0b' : '#10b981';
        this.ctx.fillStyle = powerColor;
        this.ctx.shadowColor = powerColor;
        this.ctx.shadowBlur = 15;
        this.roundRect(powerX, powerY, powerSize, powerSize, 4);
        this.ctx.fill();

        this.ctx.restore();
        this.ctx.shadowBlur = 0;
      }
    }

    roundRect(x, y, width, height, radius) {
      this.ctx.beginPath();
      this.ctx.moveTo(x + radius, y);
      this.ctx.lineTo(x + width - radius, y);
      this.ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
      this.ctx.lineTo(x + width, y + height - radius);
      this.ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
      this.ctx.lineTo(x + radius, y + height);
      this.ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
      this.ctx.lineTo(x, y + radius);
      this.ctx.quadraticCurveTo(x, y, x + radius, y);
      this.ctx.closePath();
    }
    
    gameLoop() {
      this.update();
      this.draw();

      if (this.gameRunning) {
        // Game speed increases with score, but smoother progression
        const baseSpeed = 150;
        const speedIncrease = Math.floor(this.score / 100) * 10;
        const speed = Math.max(80, baseSpeed - speedIncrease);
        setTimeout(() => this.gameLoop(), speed);
      }
    }
    
    start() {
      this.gameRunning = true;
      this.gamePaused = false;
      this.dx = SNAKE_CONFIG.INITIAL_SPEED;
      this.dy = 0;
      this.powerUp = null;
      this.powerUpTimer = 0;
      this.stateManager.setState(SNAKE_CONFIG.GAME_STATES.PLAYING);
      this.gameLoop();
    }

    pause() {
      this.gamePaused = !this.gamePaused;
      if (!this.gamePaused && this.gameRunning) {
        this.gameLoop();
      }
    }

    reset() {
      // Reset game state
      this.snake = [...SNAKE_CONFIG.INITIAL_SNAKE];
      this.dx = 0;
      this.dy = 0;
      this.score = 0;
      this.powerUp = null;
      this.powerUpTimer = 0;

      // Reset visual elements (keep background particles)
      this.particles = this.particles.filter(p => p.life === undefined);
      this.foodGlow = 0;

      // Reset UI
      this.updateScore();
      this.generateFood();
      this.draw();

      // Return to menu state
      this.stateManager.setState(SNAKE_CONFIG.GAME_STATES.MENU);
    }
    
    gameOver() {
      this.gameRunning = false;
      this.stateManager.setState(SNAKE_CONFIG.GAME_STATES.GAME_OVER);

      // Update high score
      if (this.score > this.highScore) {
        this.highScore = this.score;
        StorageManager.setHighScore(this.highScore);
        UIManager.updateHighScore(this.highScore);
      }
    }
    
    updateScore() {
      UIManager.updateScore(this.score);
    }

    updateHighScore() {
      UIManager.updateHighScore(this.highScore);
    }
  }
  
  // Initialize game
  document.addEventListener('DOMContentLoaded', () => {
    const canvas = document.getElementById('gameCanvas');
    const game = new SnakeGame(canvas);
    
    document.getElementById('startBtn').addEventListener('click', () => {
      game.start();
    });
    
    document.getElementById('pauseBtn').addEventListener('click', () => {
      game.pause();
    });
    
    document.getElementById('resetBtn').addEventListener('click', () => {
      game.reset();
    });

    // New menu buttons
    document.getElementById('startGameBtn').addEventListener('click', () => {
      game.start();
    });

    document.getElementById('playAgainBtn').addEventListener('click', () => {
      game.reset();
      game.start();
    });

    document.getElementById('backToMenuBtn').addEventListener('click', () => {
      game.reset();
    });

    // Initial draw
    game.draw();
  });
</script>

<style>
  @keyframes float {
    0%, 100% { transform: translateY(0px); }
    50% { transform: translateY(-10px); }
  }

  @keyframes glow {
    0%, 100% { box-shadow: 0 0 20px rgba(139, 92, 246, 0.3); }
    50% { box-shadow: 0 0 30px rgba(139, 92, 246, 0.6); }
  }

  .animate-float {
    animation: float 3s ease-in-out infinite;
  }

  .canvas-glow {
    animation: glow 2s ease-in-out infinite;
  }
</style>
